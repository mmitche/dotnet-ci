# Configuring your repo for Jenkins CI

This document contains information on how to set up Jenkins CI for your repo.

## Overview

The CI systems located at https://ci.dot.net and https://ci2.dot.net serve a large number of projects in the .NET Foundation and Microsoft.  These are fairly standard Jenkins instances running in Azure with access to a large number of automatically provisioned VM images as well as some real hardware (e.g. OSX)

### What can Jenkins do?

In the most basic sense, Jenkins is a task scheduling and management system.  Given a set of jobs that need to be run based on certain triggers (e.g. GitHub pushes or pull requests), run those jobs on a specific pool of machines.  While tons of those sort of systems have been created over the years, the great thing about Jenkins is its flexibility and plugin model.  There are thousands of plugins for Jenkins which automate tasks that we would normally need to deal with ourselves.

### How does the .NET CI model work?

While Jenkins does have a rich UI for configuring jobs, maintaining a large number of jobs this way is inefficient, cumbersome and prone to error.  Furthermore, it's difficult to version and backup the system when it is configured like this.  Luckily, Jenkins has a plugin that solves just this problem.  The Job DSL plugin enables the creation of jobs (as well as other types of Jenkins assets) using a Groovy-based DSL (domain specific language).  See https://github.com/jenkinsci/job-dsl-plugin for more information.

Here is the lifecycle of .NET CI.

  1. At the root of a .NET CI instance, a root generator job creates a few "base" jobs for system operation.
  2. One of these jobs is called the 'meta generator'.  It's job is to watch the dotnet-ci repository for changes, specifically to changes to the (repo list][../jobs/data/repolist.txt].
  3. This repo list defines what projects and branches that .NET CI will monitor.
  4. When the repo list changes (or supporting libraries), the meta generator is run.
  5. For each repo specified in the list, the meta generator creates a new folder for that project and a generator.  The generator watches the repo's netci.groovy (or other specified CI definition) file in the root of the specified branch for changes, as well as changes to dotnet-ci (which contains SDK functionality)
  6. The meta generator also generates a 'GenPRTest' folder underneath the project folder and a generator in that folder.  Functionally, that generator is equivalent to the 'normal' one, but it is able to do a test compilation of the netci.groovy file.
  6. PRs modifying the CI definition (netci.groovy, etc.) can commment 'test ci please' to launch a test compilation.  The test compilation creates all the same jobs as the real generator and then disables them (to avoid them running by on someone else's PR).  These jobs can be either manually examined for correctness or run manually to verify their functionality.  Please see (testing CI changes )[/docs/TESTING-NECI-CHANGES.md] for information.
  7. Upon commit, the primary generator runs and modifies/adds jobs.  Existing jobs that are removed (were generated by the previous run but not by this one) are disabled and are deleted overnight.

## Onboarding steps for your project

Below contains information on how to onboard your project onto Jenkins.

  1. Send a PR to dotnet-ci adding your repo to jobs\data\repolist.txt.  The server (dotnet-ci or dotnet-ci2) is specified in the line.  Typically dotnet-ci is used, though newer repos may use dotnet-ci2.  Please indicate 
  2. Ensure your repo is accessible by @dotnet-bot (for PR status updates).
  3. Configure web hooks for the CI.  You need two entries:
    * A GitHub webhook for push events - Go into the repo settings, click "Webhooks", then click "Add webhook".
        - Payload URL: https://ci.dot.net/github-webhook/ (For projects on dotnet-ci2, use https://ci2.dot.net/github-webhook/)
        - Content type: application/x-www-form-urlencoded
        - "Just send me the push event"
    * A GitHub webhook for pull request events - Go into the repo settings, click "Webhooks", then click "Add webhook".
      - Payload URL: https://ci.dot.net/ghprbhook/ (For projects on dotnet-ci2, use https://ci2.dot.net/ghprbhook/)
      - Content type: application/x-www-form-urlencoded
      - "Let me select individual events"
        - Pull request
        - Issue comment
  3. Create a file called netci.groovy in root of your repo in the target branch (this could also be named something different based on the line in the repolist.txt file).
  4. [Write your CI definition](WRITING-NETCI.md)
  5. PR the netci.groovy, /cc @mmitche for review and comment "test ci please" to the PR thread.
  6. Once the test generation completes, you may examine the jobs for correctness by clicking on the Details link of the job.
  7. Commit changes - The generator will check for changes to the repo  effect between 0-15 mins, after which time your jobs will be active.
